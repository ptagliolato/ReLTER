#' Obtain the observations from a sensor.
#' @description `r lifecycle::badge("experimental")`
#' This function obtains the observations shared by
#' procedure/sensor through Sensor Observation Service (SOS).
#' @param procedure A `character`. It is a procedure/sensor ID.
#' @param sosURL A `character`. The endpoint of the Sensor Observation Service
#' (SOS) service.
#' @param show_map A `boolean`. When TRUE the boundary will be plotted on a
#' Leaflet map. Default FALSE.
#' @return The output of the function is a `sf` of observations shared by
#' procedure/sensor through Sensor Observation Service (SOS). The table
#' contains SRS (Spatial Reference System) of the feature where the
#' observations are collected, the ID of the feature, the geometry of the
#' feature, and all the observed properties (e.g. phenomenonTime and
#' Air_Temperature) provided by the sensor. The observed properties are
#' enriched by the semantic link, as provided by SOS.
#' For the Unit Of Measurement (UOM) assigned to the observed properties
#' the labeling is generated by R package
#' \href{https://r-quantities.github.io/units/index.html}{`units`}
#' \insertCite{@ @utilsR}{ReLTER} in order
#' to simplify the propagation, conversation and derivation of units of
#' collected observations.
#' @author Alessandro Oggioni, phD (2020) \email{oggioni.a@@irea.cnr.it}
#' @author Paolo Tagliolato, PhD (2021) \email{tagliolato.p@@irea.cnr.it}
#' @importFrom xml2 read_xml xml_attr xml_find_all xml_text xml_find_first
#' @importFrom tidyr separate_rows separate
#' @importFrom dplyr mutate mutate_if arrange
#' @importFrom lubridate ymd_hms
#' @importFrom tibble tibble add_row tibble_row as_tibble
#' @importFrom SPARQL SPARQL
#' @importFrom sf st_as_sf
#' @importFrom leaflet leaflet addTiles addMarkers
#' @importFrom units set_units
#' @references
#'   \insertRef{utilsR}{ReLTER}
#' @export
#' @examples
#' # Fluoro Probe sensor
#' FP <- get_sos_obs(
#'   sosURL = "http://getit.lteritalia.it/observations/service",
#'   procedure = "http://www.get-it.it/sensors/getit.lteritalia.it/procedure/noOwnerDeclared/noModelDeclared/noSerialNumberDeclared/1286194C-A5DF-11DF-8ED7-1602DFD72097",
#'   show_map = FALSE
#' )
#' FP
#' 
#' # Air temperature sensor
#' airTemp <- get_sos_obs(
#'   sosURL = "http://getit.lteritalia.it/observations/service",
#'   procedure = "http://www.get-it.it/sensors/getit.lteritalia.it/procedure/noOwnerDeclared/noModelDeclared/noSerialNumberDeclared/SI000049-1675AirTemp",
#'   show_map = TRUE
#' )
#' airTemp
#' 
#' # about units of measurement (UOM)
#'  # the UOM of this observed property is °C
#' airTemp$Air_Temperature
#' # is is easily convert to °F
#' units::set_units(airTemp$Air_Temperature, "°F")
#' 
#' # about semantic enrichment
#' # the URI of the label of first two columns
#' # of `airTemp`
#' attributes(airTemp)$uri 
#'
### function get_sos_obs
get_sos_obs <- function(sosURL, procedure, show_map = FALSE) {
  requestObs <- paste0(
    sosURL,
    "?service=SOS&version=2.0.0&request=GetObservation",
    "&procedure=",
    procedure
  )
  observationDataXML <- xml2::read_xml(requestObs)
  obsPropURI <- xml2::xml_attr(xml2::xml_find_all(observationDataXML, ".//om:observedProperty"), "href")
  obsPropLabel <- xml2::xml_attr(xml2::xml_find_all(observationDataXML, ".//om:observedProperty"), "title")
  foiLabel <- xml2::xml_attr(xml2::xml_find_all(observationDataXML, ".//om:featureOfInterest"), "title")
  foiURI <- xml2::xml_attr(xml2::xml_find_all(observationDataXML, ".//om:featureOfInterest"), "href")
  numValues <- xml2::xml_find_all(observationDataXML, ".//swe:Count/swe:value/text()")
  fieldLabel <- xml2::xml_attr(xml2::xml_find_all(observationDataXML, ".//swe:field"), "name") %>%
    unique()
  nFieldLabel <- length(fieldLabel)
  # NB now is considered only fields with Quantity
  fieldURI <- xml2::xml_attr(xml2::xml_find_all(observationDataXML, ".//swe:field/swe:Quantity"), "definition") %>%
    unique()
  if (any(fieldLabel == "phenomenonTime")) {
    fieldURI <- append(fieldURI, "http://www.opengis.net/def/property/OGC/0/PhenomenonTime", 0)
  }
  fieldUOMLabel <- xml2::xml_attr(xml2::xml_find_all(observationDataXML, ".//swe:uom"), "code") %>%
    .[c(1:nFieldLabel)]
  fieldUOMURI <- xml2::xml_attr(xml2::xml_find_all(observationDataXML, ".//swe:uom"), "href") %>%
    .[c(1:nFieldLabel)]
  encodingDec <- xml2::xml_attr(xml2::xml_find_all(observationDataXML, ".//swe:TextEncoding"), "decimalSeparator")
  encodingToken <- xml2::xml_attr(xml2::xml_find_first(observationDataXML, ".//swe:TextEncoding"), "tokenSeparator")
  encodingBlock <- xml2::xml_attr(xml2::xml_find_first(observationDataXML, ".//swe:TextEncoding"), "blockSeparator")
  valuesAll <- xml2::xml_text(xml2::xml_find_all(observationDataXML, ".//swe:values/text()"))
  beginPosition <- xml2::xml_text(xml2::xml_find_all(observationDataXML, ".//gml:beginPosition/text()"))
  endPosition <- xml2::xml_text(xml2::xml_find_all(observationDataXML, ".//gml:endPosition/text()"))
  # Results ---
  results <- list()
  # NB the quantities like textual is not considered yet
  # for (m in 1:length(valuesAll)) {
  for (m in 1:10) {
    results[[m]] <- sub(paste0(encodingBlock, "+$"), "", valuesAll[[m]]) %>%
      tibble::as_tibble() %>%
      tidyr::separate_rows(value, sep = encodingBlock) %>%
      tidyr::separate(value, into = fieldLabel, sep = encodingToken)
    if (any(names(results[[m]]) == "phenomenonTime")) {
      indexTime <- which(names(results[[m]]) == "phenomenonTime")
      results[[m]] <- results[[m]] %>%
        dplyr::mutate(phenomenonTime = lubridate::ymd_hms(phenomenonTime)) %>%
        dplyr::mutate_if(is.character, as.numeric)
    }
    results[[m]]["foiLabel"] <- foiLabel[[m]]
    results[[m]]["foiURI"] <- foiURI[[m]]
    # Definition semantic enrichment ----
    attr(
      x = results[[m]],
      which = "uri"
    ) <- fieldURI
    # SPARQL for obtain UOM from QUDT
    ireaEndpoint <- "http://fuseki1.get-it.it/directory/query"
    obsProps <- tibble::tibble(
      obsProLabel = fieldLabel,
      obsProURI = fieldURI,
      obsProCode = fieldUOMLabel,
      obsProUomURI = fieldUOMURI
    )
    qudtTibble <- tibble::tibble(
      obsProQudtCode = as.character(),
      obsProQudtURI = as.character()
    )
    # only for UOM URI derived from NERC vocabularies
    for (i in 1:length(fieldUOMLabel)) {
      if (grepl("vocab.nerc.ac.uk", obsProps$obsProUomURI[1])) {
        qudtTibble <- qudtTibble %>%
          tibble::add_row(
            tibble::tibble_row(
              obsProQudtCode = "",
              obsProQudtURI = ""
            )
          )
      } else {
        if (is.na(obsProps$obsProCode[i])) {
          qudtTibble <- qudtTibble %>%
            tibble::add_row(
              tibble::tibble_row(
                obsProQudtCode = "",
                obsProQudtURI = ""
              )
            )
        } else if (obsProps$obsProCode[i] == "ug/l") {
          qudtTibble <- qudtTibble %>%
            tibble::add_row(
              tibble::tibble_row(
                obsProQudtCode = "ug.L-1",
                obsProQudtURI = "<https://qudt.org/vocab/unit/MicroGM-PER-L>"
              )
            )
        } else if (obsProps$obsProCode[i] == "Dmnless") {
          qudtTibble <- qudtTibble %>%
            tibble::add_row(
              tibble::tibble_row(
                obsProQudtCode = "",
                obsProQudtURI = ""
              )
            )
        } else {
          ireaQuery <- paste0(
            "PREFIX owl: <http://www.w3.org/2002/07/owl#>
       PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
       PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
       PREFIX qudt: <http://qudt.org/schema/qudt/>
       SELECT ?c ?l ?code ?s
        WHERE {
          SERVICE <http://vocab.nerc.ac.uk/sparql/sparql> {
            ?c rdf:type skos:Concept .
            <http://vocab.nerc.ac.uk/collection/P06/current/> skos:member ?c .
            OPTIONAL {
              ?c skos:altLabel ?l .
              ?c owl:sameAs ?s .
            }
            FILTER(?l = '",
            obsProps$obsProCode[i],
            # uom,
            "')
            FILTER(REGEX(STR(?s), 'qudt'))
          }
          SERVICE <https://www.qudt.org/fuseki/qudt/query> {
  	        ?s qudt:udunitsCode ?code
          }
        }
      ORDER BY ASC(?l)
      LIMIT 1"
          )
          qudtUOM <- SPARQL::SPARQL(
            url = ireaEndpoint,
            query = ireaQuery,
            curl_args = list(.encoding = "UTF-8")
          )
          qudtTibble[i, ] <- qudtUOM$results[, c(3:4)]
        }
      }
    }
    obsProps <- obsProps %>%
      tibble::add_column(
        qudtTibble
      )
    for (i in 1:nrow(obsProps)) {
      if (obsProps$obsProQudtCode[i] == "") {
        next
      } else {
        attrName <- obsProps$obsProLabel[i]
        results[[m]] <- results[[m]] %>%
          dplyr::mutate(
            !!attrName := units::set_units(
              eval(parse(text = attrName)),
              obsProps$obsProQudtCode[i],
              mode = "standard"
            )
          )
      }
    }
    if (!is.na(results[[m]])) {
      if (any(names(results[[m]]) == "phenomenonTime")) {
        results[[m]] <- results[[m]] %>% 
          dplyr::arrange(phenomenonTime)
    } else {
      results <- NA
      message(
        "\n----\n",
        "This sensor does not have collectes or provides observations yet.\n",
        "----\n"
      )
    }
  }
  
  # FOI info ----
  # CORRETTO FINO A QUI !!! --------
  foisInfo <- get_sos_foi(sosURL, procedure)
  # info geo offering ----
  if (is.na(attributes(foisInfo)$coords)) {
    point <- NULL
    if (show_map == TRUE) {
      message(
        "\n----\n",
        "This sensor does not have collectes or provides observations yet.\n",
        "The map relating to the distribution of observations cannot",
        "be drawn.\n",
        "----\n"
      )
    }
  } else {
    point <- attributes(foisInfo)$coords %>%
      tibble::as_tibble() %>%
      tidyr::separate(value, into = c("lon", "lat"), sep = " ") %>%
      sf::st_as_sf(
        coords = c("lat", "lon"),
        crs = attributes(foisInfo)$srs
      )
    coords <- sf::st_coordinates(point)
    proc <- get_sos_procedure_info(
      sosURL, procedure
    )
    
    results <- results %>%
      tibble::add_column(
        procedureName = proc[1],
        procedureID = attributes(proc)$id,
        lon = coords[1],
        lat = coords[2]
      ) %>%
      sf::st_as_sf(
        coords = c("lon", "lat"),
        crs = attributes(foisInfo)$srs
      )
    
    # observations for feature ----
    numObsForFeature <- table(results$foiLabel)
    if (show_map == TRUE) {
      map <- leaflet::leaflet() %>%
        leaflet::addTiles() %>%
        leaflet::addMarkers(
          data = results,
          popup = paste0(
            "<b>Sensor name: </b>",
            "<br>",
            "<a href='",
            results$procedureID,
            "' target='_blank'>",
            results$procedureName,
            "</a>",
            "<br>",
            "<b>Sensor coordinates: </b>",
            "<br>",
            coords[1], " ", coords[2],
            "<br>",
            "<b>Observations from this sensor: </b>",
            numObsForFeature
          )
        )
      print(map)
    }
  }
  
  return(results)
}
